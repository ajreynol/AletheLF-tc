(include "Quantifiers-rules.smt3")
(include "Booleans-rules.smt3")
(include "Builtin-rules.smt3")
(include "Uf-rules.smt3")
(declare-var alf.1.x Int)
(declare-var x Int)
(declare-var y Int)
(declare-fun P (Int Int) Bool)
(define-fun @t1 () Bool (forall (@list x y) (P x y)))
(define-fun @t2 () Bool (P alf.1.x 5))
(define-fun @t3 () Bool (exists (@list alf.1.x alf.null) (not @t2)))
(define-fun @t4 () Bool (not (forall (@list alf.1.x alf.null) @t2)))
(define-fun @t5 () Int (skolem (@k.QUANTIFIERS_SKOLEMIZE @t3 alf.1.x)))
(define-fun @t6 () Bool (P @t5 5))
(assume @p1 @t1)
(assume @p2 @t3)
; WARNING: add trust step for THEORY_REWRITE
; trust THEORY_REWRITE
(step @p3 (= @t3 @t4) :rule trust :args ((= @t3 @t4)))
(step @p4 @t4 :rule eq_resolve :premises (@p2 @p3))
(step @p5 (not @t6) :rule skolemize :premises (@p4))
(assume-push @p6 @t1)
(step @p7 @t6 :rule instantiate :premises (@p1) :args ((@list @t5 5)))
(step-pop @p8 (=> @t1 @t6) :rule scope :premises (@p7))
(step @p9 (or (not @t1) @t6) :rule implies_elim :premises (@p8))
(step @p10 false :rule chain_resolution :premises (@p9 @p5 @p1) :args ((and true @t6 false @t1)))

